import os
import random
import time

from dotenv import load_dotenv
import redis
import vk_api
from vk_api.keyboard import VkKeyboard, VkKeyboardColor
from vk_api.longpoll import VkEventType, VkLongPoll

from quiz_utils import (WELCOME_MESSAGE, States, check_answer, clean_answer,
                        get_current_question, get_random_question,
                        get_redis_keys, get_user_score, get_user_state,
                        increment_user_score, load_all_questions,
                        save_question_to_redis, set_user_state)


def create_keyboard():
    keyboard = VkKeyboard(one_time=True)
    
    keyboard.add_button('üÜï –ù–æ–≤—ã–π –≤–æ–ø—Ä–æ—Å', color=VkKeyboardColor.PRIMARY)
    keyboard.add_button('üè≥Ô∏è –°–¥–∞—Ç—å—Å—è', color=VkKeyboardColor.NEGATIVE)
    keyboard.add_line()
    keyboard.add_button('üìä –ú–æ–π —Å—á–µ—Ç', color=VkKeyboardColor.SECONDARY)
    
    return keyboard.get_keyboard()


def send_message(vk, user_id, message, keyboard=None):
    vk.messages.send(
        user_id=user_id,
        message=message,
        random_id=random.randint(1, 10000),
        keyboard=keyboard
    )


def handle_start(vk, user_id, redis_client):
    keyboard = create_keyboard()
    send_message(vk, user_id, WELCOME_MESSAGE, keyboard)
    set_user_state(redis_client, user_id, States.CHOOSING)


def handle_new_question(vk, user_id, redis_client, questions_dict):
    keys = get_redis_keys(user_id)
    
    question, answer = get_random_question(questions_dict)
    save_question_to_redis(redis_client, keys['question'], question, answer)
    keyboard = create_keyboard()
    send_message(vk, user_id, f"‚ùì {question}", keyboard)
    set_user_state(redis_client, user_id, States.ANSWERING)


def handle_solution_attempt(vk, user_id, message, redis_client):
    keys = get_redis_keys(user_id)
    
    question_data = get_current_question(redis_client, keys['question'])
    correct_answer = question_data['answer']
    
    if check_answer(message, correct_answer):
        increment_user_score(redis_client, user_id)
        keyboard = create_keyboard()
        send_message(vk, user_id, "–ü—Ä–∞–≤–∏–ª—å–Ω–æ! –ü–æ–∑–¥—Ä–∞–≤–ª—è—é! –î–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –≤–æ–ø—Ä–æ—Å–∞ –Ω–∞–∂–º–∏ ¬´–ù–æ–≤—ã–π –≤–æ–ø—Ä–æ—Å¬ª", keyboard)
        redis_client.delete(keys['question'])
        set_user_state(redis_client, user_id, States.CHOOSING)
    else:
        keyboard = create_keyboard()
        send_message(vk, user_id, "–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ‚Ä¶ –ü–æ–ø—Ä–æ–±—É–µ—à—å –µ—â—ë —Ä–∞–∑?", keyboard)


def handle_give_up(vk, user_id, redis_client, questions_dict):
    keys = get_redis_keys(user_id)
    
    question_data = get_current_question(redis_client, keys['question'])
    answer = question_data['answer']
    clean_answer_text = clean_answer(answer)
    keyboard = create_keyboard()
    send_message(vk, user_id, f"‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç: {clean_answer_text}", keyboard)
    
    question, answer = get_random_question(questions_dict)
    save_question_to_redis(redis_client, keys['question'], question, answer)
    keyboard = create_keyboard()
    send_message(vk, user_id, f"‚ùì {question}", keyboard)
    set_user_state(redis_client, user_id, States.ANSWERING)


def handle_score(vk, user_id, redis_client):
    current_score = get_user_score(redis_client, user_id)
    keyboard = create_keyboard()
    send_message(vk, user_id, f"üìä –í–∞—à —Å—á–µ—Ç: {current_score} –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤", keyboard)


def main():
    load_dotenv()
    
    vk_token = os.environ["VK_GROUP_TOKEN"]
    redis_url = os.environ["REDIS_URL"]
    quiz_data_path = os.environ["QUIZ_DATA_PATH"]
    
    redis_client = redis.from_url(redis_url, decode_responses=True)
    questions_dict = load_all_questions(quiz_data_path)
    
    vk_session = vk_api.VkApi(token=vk_token)
    vk = vk_session.get_api()
    
    longpoll = VkLongPoll(vk_session)
    
    while True:
        try:
            for event in longpoll.listen():
                if event.type == VkEventType.MESSAGE_NEW and event.to_me:
                    user_id = event.user_id
                    message = event.text.strip()
                    
                    user_state = get_user_state(redis_client, user_id)
                    
                    if message.lower() in ['–ø—Ä–∏–≤–µ—Ç', 'hello', 'hi', 'start']:
                        handle_start(vk, user_id, redis_client)
                    elif user_state == States.CHOOSING:
                        if message == 'üÜï –ù–æ–≤—ã–π –≤–æ–ø—Ä–æ—Å':
                            handle_new_question(vk, user_id, redis_client, questions_dict)
                        elif message == 'üìä –ú–æ–π —Å—á–µ—Ç':
                            handle_score(vk, user_id, redis_client)
                        else:
                            handle_start(vk, user_id, redis_client)
                    elif user_state == States.ANSWERING:
                        if message == 'üè≥Ô∏è –°–¥–∞—Ç—å—Å—è':
                            handle_give_up(vk, user_id, redis_client, questions_dict)
                        elif message == 'üìä –ú–æ–π —Å—á–µ—Ç':
                            handle_score(vk, user_id, redis_client)
                        elif message == 'üÜï –ù–æ–≤—ã–π –≤–æ–ø—Ä–æ—Å':
                            handle_new_question(vk, user_id, redis_client, questions_dict)
                        else:
                            handle_solution_attempt(vk, user_id, message, redis_client)
        except Exception as e:
            time.sleep(5)


if __name__ == "__main__":
    main() 